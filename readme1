# README â€” Cross-compilation & Kernel Module pour GPIO sur BeagleBone Black (BBB)

Ce document rÃ©sume **toutes les Ã©tapes** effectuÃ©es dans la conversation prÃ©cÃ©dente,  
sous forme **100% code**, y compris les explications, commentaires, Ã©tapes, et commandes.

---

# ============================================
# 1ï¸âƒ£ PRÃ‰REQUIS ET OBJECTIF
# ============================================

# Objectif :
# - Compiler sur un PC (Mac) un *module noyau* (.ko)
# - Ce module allume/Ã©teint des GPIO de la BeagleBone Black
# - Cross-compiler en utilisant Docker + toolchain ARM
# - Charger le module sur la BBB et l'exÃ©cuter

# On nâ€™utilise *que des GPIO* (puisque PWM nâ€™Ã©tait pas possible via module).
# Les GPIO utilisÃ©s = P8_10 (GPIO68), P8_8 (GPIO67), P8_9 (GPIO69), P8_26 (GPIO61)

---

# ============================================
# 2ï¸âƒ£ RÃ‰CUPÃ‰RATION DES HEADERS DU NOYAU SUR BBB
# ============================================

# Sur la BBB (SSH)
uname -r
# Exemple : 4.19.94-ti-r42

# VÃ©rifier si les headers existent dÃ©jÃ  :
ls -l /lib/modules/$(uname -r)/build

# Si build nâ€™existe PAS (ton cas) :
# TÃ©lÃ©charger directement le .deb des headers :
# (tu l'avais tÃ©lÃ©chargÃ© via ton Mac puis transfÃ©rÃ©)

sudo dpkg -i linux-headers-4.19.94-ti-r42_1stretch_armhf.deb

# VÃ©rifier l'installation :
ls -l /usr/src/linux-headers-4.19.94-ti-r42

# Et vÃ©rifier le lien vers /lib/modules :
ls -l /lib/modules/4.19.94-ti-r42/build

# Maintenant build â†’ headers OK âœ”ï¸

---

# ============================================
# 3ï¸âƒ£ COPIER LES HEADERS SUR LE MAC
# ============================================

# Sur le Mac : crÃ©er dossier
mkdir ~/bbb-module/kernel_headers

# Copier les headers depuis la BBB :
scp -r debian@192.168.6.2:/usr/src/linux-headers-4.19.94-ti-r42 ~/bbb-module/kernel_headers/usr/src/

# RÃ©sultat attendu :
# ~/bbb-module/kernel_headers/usr/src/linux-headers-4.19.94-ti-r42

---

# ============================================
# 4ï¸âƒ£ PRÃ‰PARATION DU PROJET (MAC)
# ============================================

# Arborescence du dossier :
# bbb-module/
#   â”œâ”€â”€ Makefile
#   â”œâ”€â”€ full_ctrl.c
#   â”œâ”€â”€ kernel_headers/
#        â””â”€â”€ usr/src/linux-headers-4.19.94-ti-r42/

---

# ============================================
# 5ï¸âƒ£ FICHIER Makefile
# ============================================

cat > Makefile << 'EOF'
obj-m += full_ctrl.o

PWD := $(shell pwd)
KDIR := $(PWD)/kernel_headers/usr/src/linux-headers-4.19.94-ti-r42

all:
	make -C $(KDIR) M=$(PWD) ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules

clean:
	make -C $(KDIR) M=$(PWD) clean
EOF

---

# ============================================
# 6ï¸âƒ£ MODULE C (GPIO BLINK 1 Hz)
# ============================================

cat > full_ctrl.c << 'EOF'
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/gpio.h>
#include <linux/delay.h>
#include <linux/kthread.h>

static int gpios[4] = {68, 67, 69, 61};
static struct task_struct *blink_thread;

// Thread qui clignote les 4 GPIO
static int blink_func(void *data)
{
    while (!kthread_should_stop()) {
        int i;
        for (i = 0; i < 4; i++)
            gpio_set_value(gpios[i], 1);
        msleep(1000);

        for (i = 0; i < 4; i++)
            gpio_set_value(gpios[i], 0);
        msleep(1000);
    }
    return 0;
}

static int __init full_init(void)
{
    int i;
    printk(KERN_INFO "full_ctrl: init\n");

    for (i = 0; i < 4; i++) {
        gpio_request(gpios[i], "fullctrl_gpio");
        gpio_direction_output(gpios[i], 0);
    }

    blink_thread = kthread_run(blink_func, NULL, "blink_thread");
    printk(KERN_INFO "full_ctrl: thread started\n");

    return 0;
}

static void __exit full_exit(void)
{
    int i;

    printk(KERN_INFO "full_ctrl: stopping\n");

    if (blink_thread)
        kthread_stop(blink_thread);

    for (i = 0; i < 4; i++) {
        gpio_set_value(gpios[i], 0);
        gpio_free(gpios[i]);
    }

    printk(KERN_INFO "full_ctrl: exit complete\n");
}

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Antoine");
MODULE_DESCRIPTION("Blink 4 GPIO each second BBB");
module_init(full_init);
module_exit(full_exit);
EOF

---

# ============================================
# 7ï¸âƒ£ BUILD AVEC DOCKER SUR MAC
# ============================================

cd ~/bbb-module

docker run --rm -it \
  -v "$(pwd)":/src \
  -v "$(pwd)/kernel_headers/usr/src/linux-headers-4.19.94-ti-r42":/kernel \
  arm32v7/debian:bookworm bash

# Dans le container :
apt update
apt install -y build-essential gcc make

cd /src
make

# RÃ©sultat attendu :
#   full_ctrl.ko gÃ©nÃ©rÃ© âœ”ï¸

exit

---

# ============================================
# 8ï¸âƒ£ TRANSFERT DU MODULE SUR LA BBB
# ============================================

scp full_ctrl.ko debian@192.168.6.2:~

---

# ============================================
# 9ï¸âƒ£ CHARGER LE MODULE SUR LA BBB
# ============================================

ssh debian@192.168.6.2

sudo insmod full_ctrl.ko

# VÃ©rifier dans dmesg :
dmesg | tail

# Doit afficher :
# full_ctrl: init
# full_ctrl: thread started

---

# ============================================
# ðŸ”Ÿ ARRÃŠTER LE MODULE
# ============================================

sudo rmmod full_ctrl

# VÃ©rifier :
dmesg | tail
# => full_ctrl: stopping
# => full_ctrl: exit complete

---

# ============================================
# ðŸ”¥ FONCTIONNEMENT FINAL
# ============================================

# Une fois insmod exÃ©cutÃ© :
# â†’ Les 4 GPIO (P8_10, P8_8, P8_9, P8_26)
#   clignotent automatiquement :
#       1 seconde ON
#       1 seconde OFF
#       en boucle
# â†’ Le tout fait par un thread noyau (kthread) dans le module

# Aucun script externe nÃ©cessaire.
# Aucun config-pin nÃ©cessaire.
# Le module pilote directement les GPIO.

---